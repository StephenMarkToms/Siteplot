"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

"""
Add a dynamically client-controlled WHERE condition to a fields query.
"""
directive @whereConditions(
  """
  Restrict the allowed column names to a well-defined list.
  This improves introspection capabilities and security.
  Mutually exclusive with the `columnsEnum` argument.
  """
  columns: [String!]

  """
  Use an existing enumeration type to restrict the allowed columns to a predefined list.
  This allowes you to re-use the same enum for multiple fields.
  Mutually exclusive with the `columns` argument.
  """
  columnsEnum: String
) on ARGUMENT_DEFINITION

type AssetEntry {
    id: ID!
    path: String!
    website: Website! @belongsTo
    created_at: DateTime!
    updated_at: DateTime!
}

type BlockEntry {
    id: ID!
    block_type_id: ID!
    order: Number!
    usage: String!
    widget_entries: WidgetEntry! @belongsToMany
    block_type: BlockType! @belongsTo
    created_at: DateTime!
    updated_at: DateTime!
}

type BlockType {
    id: ID!
    name: String!
    file_name: String!
    component: String
    team_id: ID
    created_at: DateTime!
    updated_at: DateTime!
    repositories: [Repository!] @belongsToMany
}

type Collection {
    id: ID!
    name: String!
    website: Website! @belongsTo
    created_at: DateTime!
    updated_at: DateTime!
}

type DataType {
    id: ID!
    name: String!
    data: String!
}

type LayoutEntry {
    id: ID!
    name: String!
    block_entries: BlockEntry! @belongsToMany
    website: Website! @belongsTo
    created_at: DateTime!
    updated_at: DateTime!
}

type User {
    id: ID!
    name: String!
    email: String!
    created_at: DateTime!
    updated_at: DateTime!
}

type Website {
    id: ID!
    name: String!
    domain: String!
    team_id: Number!
    netlify_build_hook: String
    created_at: DateTime!
    updated_at: DateTime!
}

type WidgetEntry {
    id: ID!
    widget_type_id: ID!
    value: String!
    widget_type: WidgetType! @belongsTo
}

type WidgetType {
    id: ID!
    name: String!
    label: String!
    usage: String!
    order: Number!
    data_type: DataType! @belongsTo
}

type Repository {
    id: ID!
    name: String!
    path: String
    personal_access_token: String
    block_types: BlockType @belongsToMany
}

type Query {
    asset_entries: [AssetEntry!]! @paginate

    block_entries: [BlockEntry!]! @paginate
    block_entry(id: Int! @eq): BlockEntry @find

    block_types: [BlockType!]! @paginate
    block_type(id: Int! @eq): BlockType @find
    search_block_types(where: _ @whereConditions(columnsEnum: "BlockTypeColumn")): [BlockType!]! @paginate @orderBy(column: "updated_at", direction: DESC) @guard

    collections: [Collection!]! @paginate
    collection(id: Int! @eq): Collection @find

    data_types: [DataType!]! @paginate
    data_type(id: Int! @eq): DataType @find

    layout_entries: [LayoutEntry!]! @paginate
    layout_entry(id: Int! @eq): LayoutEntry @find

    me: User @auth
    
    users: [User!]! @paginate
    user(id: ID @eq, name: String @eq): User @find

    websites(where: _ @whereConditions(columnsEnum: "WebsiteColumn")): [Website!]! @paginate @orderBy(column: "updated_at", direction: DESC) @guard

    website(id: ID @eq): Website @find

    widget_entries: [WidgetEntry!]! @paginate
    widget_entry(id: Int! @eq): WidgetEntry @find

    widget_types: [WidgetType!]! @paginate
    widget_type(id: Int! @eq): WidgetType @find

    repositories(where: _ @whereConditions(columnsEnum: "RepositoryColumn")): [Repository!]! @paginate @orderBy(column: "updated_at", direction: DESC) @guard

}

"A custom description for this custom enum."
enum WebsiteColumn {
  NAME @enum(value: "name")
  DOMAIN @enum(value: "domain")
}

"A custom description for this custom enum."
enum BlockTypeColumn {
  NAME @enum(value: "name")
  DOMAIN @enum(value: "file_name")
}

enum RepositoryColumn {
  NAME @enum(value: "name")
  PATH @enum(value: "path")
}

type Mutation {
  createUser(name: String!, domain: String!, netlify_build_hook: String): User! @create @guard
  updateUser(id: ID!, name: String, name: String, email: String): User! @update @guard
  deleteUser(id: [ID!]!): [User!]! @delete
  
  createUser(name: String!, email: String!, password: String!): User! @create
  updateUser(id: ID!, name: String, email: String): User @update

  createWebsite(name: String!, domain: String!, netlify_build_hook: String): Website! @create @guard
  updateWebsite(id: ID!, name: String, domain: String, netlify_build_hook: String): Website! @update @guard
  deleteWebsite(id: [ID!]!): [Website!]! @delete @guard


#   updateBlockType(id: ID!, name: String!, file_name: String!, component: String, repositories: [ID]): BlockType! @update @guard
#   deleteBlockType(id: [ID!]!): [BlockType!]! @delete @guard
  createBlockType(input: CreateBlockTypeInput! @spread): BlockType @create
}

input CreateBlockTypeInput {
    name: String!
    file_name: String!
    component: String
    repositories: CreateRepositoryBelongsToMany
}

input CreateRepositoryBelongsToMany {
  create: [CreateRepositoryInput!]
  upsert: [UpsertRepositoryInput!]
  connect: [ID!]
  sync: [ID!]
}

input CreateRepositoryInput {
  name: String!
}

input UpsertRepositoryInput {
  id: ID!
  name: String!
}

